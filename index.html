<!DOCTYPE html>
<html lang=en>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    
    <meta property="og:type" content="website">
<meta property="og:title" content="Ran Varshaver">
<meta property="og:url" content="https://ran-var.github.io/blog/">
<meta property="og:site_name" content="Ran Varshaver">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Ran Varshaver">
<meta name="twitter:card" content="summary">
    
    
    
    
      
        <link rel="shortcut icon" href="/images/favicon.ico">
      
      
        <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
      
      
        <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
      
    

    <title>Ran Varshaver</title>

    <!-- async scripts -->
    
    

    
<link rel="stylesheet" href="/blog/css/style.css">


    

    
<meta name="generator" content="Hexo 7.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
    <div class="content index py4 h-card">
        
          <header id="header">
  <a class="u-url u-uid" href="/blog/">
    
      
        <img
          id="logo"
          alt
          class="u-logo"
          src="/blog/images/logo.png"
        />
      
    
    <div id="title">
      <h1 class="p-name">Ran Varshaver</h1>
      <h2 class="subtitle">Security Researcher</h2>
    </div>
  </a>
  <div id="nav">
    <ul>
      <li class="icon">
        <a href="#" aria-label="Menu">
          <i class="fa-solid fa-bars fa-2x"></i>
        </a>
      </li>
    </ul>
  </div>
</header>

        
        <section id="about" class="p-note">
  <p>
    Hey! I'm Ran, I do security for work and kitesurf for sanity. <br>
    I like to write whatever comes to my mind on here.
  </p>

  
    <p>
      Find me on
      
      
      
        
        
          <a class="icon u-url" target="_blank" rel="noopener me" href="https://github.com/ran-var" aria-label="github" title="github">
            <i class="fa-brands fa-github"></i>
          </a>
        
        , 
        
      
        
        
          <a class="icon u-url" target="_blank" rel="noopener me" href="https://www.linkedin.com/in/ranvarshaver/" aria-label="linkedin" title="linkedin">
            <i class="fa-brands fa-linkedin"></i>
          </a>
        
         and 
        
      
        
        
          <a class="icon u-email" target="_blank" rel="noopener" href="mailto:ran.varshaver1@gmail.com" aria-label="mail" title="mail">
            <i class="fa-solid fa-envelope"></i>
          </a>
        
        .
        
      
    </p>
  
</section>

<section id="writing">
  <span class="h1"><a href="/blog/">Writing</a></span>
  
  
  <ul class="post-list">
    
    
         
    
      <li class="post-item" data-content="Poking at Chinese FirmwareI recently spent some time reversing a pre-historic smart device as a research exercise. While poking at the firmware binaries I stumbled on a bug inside how the device parses the config XML file.The vendor hasn’t issued a statement yet(shocker) so I will try to the best of my ability to recreate a similar vulnerable function without accidentally disclosing any real detail that can be used to identify the device.
Understanding XML: Structure Without SafetyXML (eXtensible Markup Language) is a markup language that uses a hierarchical structure of elements enclosed in angle brackets.Think of XML as a structuring system where information gets organized into labeled elements that can hold both data and other elements.
1234&lt;device&gt;	&lt;name&gt;Generic Router&lt;/name&gt;	&lt;firmware_version&gt;2.1&lt;/firmware_version&gt;&lt;/device&gt;
XML elements can also contain attributes which provide additional metadata about the element, an attribute appears inside the opening tag and consists of a name-value pair:
1&lt;device type=&quot;thermostat&quot; model=&quot;v2.1&quot;&gt;Smart Home Device&lt;/device&gt;

Nowadays XML is often compared and somewhat replaced by JSON or YAML which are considered lighter and simpler alternatives, but it remains a standard in government, healthcare, telecom, IoT, and finance systems where strict schemas and validation are critical.
However, XML’s verbose nature and complex parsing requirements create more opportunities for security vulnerabilities. XML parsers must handle opening and closing tags, attributes, namespaces, character encoding, and various formatting edge cases.
Learning from Critical VulnerabilitiesTwo critical XML parsing vulnerabilities demonstrate just how dangerous these flaws can be in production systems.
CVE-2016-1834 affected libxml2 &lt;2.9.4, a widely used XML parsing library. The vulnerability is a heap based buffer overflow in the xmlStrncat function which allowed attackers to execute remote code or cause a memory corruption based denial of service attack. The vulnerability was especially significant on Apple platforms, though unpatched Linux systems using libxml2 were also at risk.
CVE-2019-5063 affected OpenCV 4.1.0. It also involves a heap based buffer overflow in the XML parser, triggered when processing very long or unrecognized character entities in XML files and copying it into a fixed size buffer without proper bounds checking:
12#define CV_FS_MAX_LEN 4096char strbuf[CV_FS_MAX_LEN + 16];

Config Parsing in IoT DevicesTo see how XML buffer overflows can happen in IoT devices, let’s look at a simple configuration parser for device credentials. This example reflects the same type of flaws found in CVE-2016-1834 and CVE-2019-5063, but in the context of parsing default admin credentials from an XML file.
Many IoT devices keep default credentials and network settings in (ideally) encrypted XML files that are loaded during startup. A typical parser might look like this:
1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;libxml/parser.h&gt;typedef struct &#123;    char username[16];    char password[32];    char device_id[36];    char wifi_ssid[32];    int config_version;&#125; config_t;int parse_config(const char* filename, config_t* cfg) &#123;    xmlDocPtr doc = xmlParseFile(filename);    if (!doc) return -1;    xmlNodePtr root = xmlDocGetRootElement(doc);    if (!root) &#123; xmlFreeDoc(doc); return -1; &#125;    xmlNodePtr node;    char buf[256];    for (node = root-&gt;children; node; node = node-&gt;next) &#123;        if (node-&gt;type != XML_ELEMENT_NODE) continue;        char* content = (char*)xmlNodeGetContent(node);        if (!content) continue;        strcpy(buf, content);        if (strcmp((char*)node-&gt;name, &quot;username&quot;) == 0)            strcpy(cfg-&gt;username, buf);        else if (strcmp((char*)node-&gt;name, &quot;password&quot;) == 0)            strcpy(cfg-&gt;password, buf);        else if (strcmp((char*)node-&gt;name, &quot;device_id&quot;) == 0)            strcpy(cfg-&gt;device_id, buf);        else if (strcmp((char*)node-&gt;name, &quot;wifi_network&quot;) == 0)            strcpy(cfg-&gt;wifi_ssid, buf);        else if (strcmp((char*)node-&gt;name, &quot;config_ver&quot;) == 0)            cfg-&gt;config_version = atoi(buf); //only safe part of the parser        xmlFree(content);    &#125;    xmlFreeDoc(doc);    return 0;&#125;

The full vulnerable parser can be found here.With our parser compiled, we can inspect exactly what happens when an attacker supplies malicious input.
123pwndbg xml_demopwndbg&gt; b parse_configpwndbg&gt; r

Once inside we can just step over instructions until we hit the part where our trustworthy password is copied into memory.
12345678910111213141516171819202122232425262728─────────────────────────────────[ SOURCE (CODE) ]─────────────────────────────────In file: /home/rvarr/xml_overflow/parser.c:27   22         strcpy(buf, content);   23    24         if (strcmp((char*)node-&gt;name, &quot;username&quot;) == 0)   25             strcpy(cfg-&gt;username, buf);   26         else if (strcmp((char*)node-&gt;name, &quot;password&quot;) == 0) ► 27             strcpy(cfg-&gt;password, buf);   28         else if (strcmp((char*)node-&gt;name, &quot;device_id&quot;) == 0)   29             strcpy(cfg-&gt;device_id, buf);   30         else if (strcmp((char*)node-&gt;name, &quot;wifi_network&quot;) == 0)   31             strcpy(cfg-&gt;wifi_ssid, buf);   32         else if (strcmp((char*)node-&gt;name, &quot;config_ver&quot;) == 0)─────────────────────────────────────[ STACK ]─────────────────────────────────────00:0000│ rsp 0x7fffffffd890 —▸ 0x7fffffffd9d0 ◂— 0x6e696d6461 /* &#x27;admin&#x27; */01:0008│-128 0x7fffffffd898 —▸ 0x555555556004 ◂— &#x27;config.xml&#x27;02:0010│-120 0x7fffffffd8a0 ◂— &#x27;\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA  \nBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB  \nCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC  \nDDDD                              \n    &#x27;03:0018│-118 0x7fffffffd8a8 ◂— &#x27;AAAAAAAAAAAAAAAAAAAAAAAAA  \nBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB  \nCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC  \nDDDD                              \n    &#x27;... ↓        2 skipped06:0030│-100 0x7fffffffd8c0 ◂— &#x27;A  \nBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB  \nCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC  \nDDDD                              \n    &#x27;07:0038│-0f8 0x7fffffffd8c8 ◂— &#x27;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB  \nCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC  \nDDDD                              \n    &#x27;───────────────────────────────────[ BACKTRACE ]─────────────────────────────────── ► 0   0x5555555553b0 parse_config+278   1   0x5555555551dd main+36   2   0x7ffff7c24ca8 None   3   0x7ffff7c24d65 __libc_start_main+133   4   0x5555555550f1 _start+33───────────────────────────────────────────────────────────────────────────────────

At this point we’re right at the instruction that causes the overflow, so once we step over into the next instruction and inspect the memory at the struct.
123456789101112131415161718pwndbg&gt; npwndbg&gt; x/128bx &amp;cfg-&gt;password0x7fffffffd9f0:	0x0a	0x41	0x41	0x41	0x41	0x41	0x41	0x410x7fffffffd9f8:	0x41	0x41	0x41	0x41	0x41	0x41	0x41	0x410x7fffffffda00:	0x41	0x41	0x41	0x41	0x41	0x41	0x41	0x410x7fffffffda08:	0x41	0x41	0x41	0x41	0x41	0x41	0x41	0x410x7fffffffda10:	0x41	0x20	0x20	0x0a	0x42	0x42	0x42	0x420x7fffffffda18:	0x42	0x42	0x42	0x42	0x42	0x42	0x42	0x420x7fffffffda20:	0x42	0x42	0x42	0x42	0x42	0x42	0x42	0x420x7fffffffda28:	0x42	0x42	0x42	0x42	0x42	0x42	0x42	0x420x7fffffffda30:	0x42	0x42	0x42	0x42	0x42	0x42	0x42	0x420x7fffffffda38:	0x42	0x42	0x42	0x42	0x20	0x20	0x0a	0x430x7fffffffda40:	0x43	0x43	0x43	0x43	0x43	0x43	0x43	0x430x7fffffffda48:	0x43	0x43	0x43	0x43	0x43	0x43	0x43	0x430x7fffffffda50:	0x43	0x43	0x43	0x43	0x43	0x43	0x43	0x430x7fffffffda58:	0x43	0x43	0x43	0x43	0x43	0x43	0x43	0x200x7fffffffda60:	0x20	0x0a	0x44	0x44	0x44	0x44	0x20	0x200x7fffffffda68:	0x20	0x20	0x20	0x20	0x20	0x20	0x20	0x20

Setting this memory view side by side with config.xml we are able to directly see the hex representation of the ASCII characters we’ve overflown the memory with:A=0x41*32, B=0x42*36, C=0x43*32, D=0x44*4 
This example was a significant oversimplification of how IoT&#x2F;smart home devices utilize XML for parsing credentials, but it gets the point across: blindly trusting XML and dumping it into fixed-size buffers is risky.In real-world applications, it can crash devices, overwrite important memory, or even open the door to more serious exploits just as we’ve seen with the two CVEs covered and many more that have been discovered over the years.
">
        
    <div class="meta">
      
        
          <time datetime="2025-09-16T00:00:00.000Z" class="dt-published" itemprop="datePublished">16-09-2025</time>
        
      
    </div>


        <span>
    
        <a class="" href="/blog/2025/09/16/xml-overflow/">Stack Smashing Through XML: Using IoT Configs As Attack Vectors</a>
    


</span>
        <span class="reading-time"></span>
      </li>
    
  </ul>

  

  <script>
    document.querySelectorAll('.post-item').forEach(item => {
      const text = item.getAttribute('data-content') || '';
      const words = text.trim().split(/\s+/).length;
      const minutes = Math.max(1, Math.ceil(words / 200));
      const span = item.querySelector('.reading-time');
      if(span) span.textContent = minutes + ' min read';
    });
  </script>
</section>




        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2025
    Ran Varshaver
  </div>
  <div class="footer-right">
  </div>
</footer>

    </div>
    

 
  <link
    rel="preload"
    href="/blog/lib/font-awesome/css/all.min.css"
    as="style"
    onload="this.onload=null;this.rel='stylesheet'"
  />
  <noscript
    ><link
      rel="stylesheet"
      href="/blog/lib/font-awesome/css/all.min.css"
  /></noscript>


    
  
<script src="/blog/lib/jquery/jquery.min.js"></script>







<script src="/blog/js/main.js"></script>



</body>
</html>
